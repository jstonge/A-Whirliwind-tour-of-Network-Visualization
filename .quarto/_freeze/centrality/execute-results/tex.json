{
  "hash": "9229ea4be067525cce79e64fbd9afa74",
  "result": {
    "markdown": "---\ntitle: \"Describing networks, then what?\"\nformat:\n  html:\n    code-fold: false\n    toc: true\n    number-sections: false\ndate: today\neditor: visual\n---\n\n\n\nHow do we describe networks in meaningful ways?\n\n```\nQ: Give me your best centrality measure?\nA: ü§∑‚Äç‚ôÇÔ∏è\nQ: There is no better centrality measure??\nA: ü§∑‚Äç‚ôÇÔ∏èü§∑‚Äç‚ôÇÔ∏èü§∑‚Äç‚ôÇÔ∏è\n```\n\nSeriously, where do we start when we want to understand our networks of interests? \n\nIn many ways, network analysis is similar to statistical analysis (sorry). It is statistics.\n\nUsually, in a typical class, we first introduce the language of networks (nodes, edges, directed, weighted, etc.), then network properties. The problem is that we need to avoid what i call the \"pitfall of itemizing\" (ok, this is a GPT4's suggestion). Lets try different paths\n\n::: {.panel-tabset}\n\n##  itemizing \n\nHere this is a list, as presented by @menczer_first_2020 (I indicate with üá® the properties that are used to measure centrality):\n\n1. density/sparsity\n1. [degree](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.degree_centrality.html#networkx.algorithms.centrality.degree_centrality) \n    i) in/out-degree\n    i) weighted; in/out-strength\n1. assortativity/homophily\n    i) degree assortativity\n    i) disassortative/core-periphery\n1. paths\n    i) [shortest path](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.betweenness_centrality.html#networkx.algorithms.centrality.betweenness_centrality) üá®\n        A. breadth-first search\n        A. depth-first search\n    i) diameter\n    i) average path length\n1. components\n    i) connected components\n    i) giant component\n    i) weakly/strongly connected components\n1. clustering coefficient/triadic closures\n1. [closeness](https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality) üá®\n1. k-core decomposition\n\n## catego\n\nscales\n\n- local: about a single item (node, edge)\n- meso: about a group of items\n- global: about the whole\n\ntypes\n\n- connectivity: related to (directly or not) to the number of contacts of \"things\" \n- position: related to position (relative, absolute)\n- motif: countrs or frequency of patterns of connection\n\nMisc\n- hubs\n\np.s. we can turn local into global by using summaries of the distribution of local properties.\n\n## algebraic\n\n- density\n\n$$d = L / L_{\\max} = \\frac{L}{\\frac{N(N-1)}{2}} = \\frac{2L}{N(N-1)}$$\n\nwhere $L_{\\max} = {N \\choose 2} = N(N-1)/2$ for undirected networks. A easy way to remember that is by seeing that $2L$ is really counting the number of edges\n\n\n::: {.callout-note collapse=\"true\"}\nWhat is a dense network? Why do we care? It often help to think in the extremes, like if $d=1$ it means that everybody is connected to everybody. If i tell you that coauthorship as much as high-school friendship networks, what does this tells you.\n\n## ${N \\choose 2}$\n\nA little extravangaza about ${N \\choose 2}$, for those who never took discrete math. Get used to ${N \\choose 2}$, but don't reify it. ${N \\choose 2}$ said N _choose_ 2 pops u eveyrtime we need to count the total number of ways _unordered_ sets can happen...\n\n${N \\choose 2}$ works well because we are in a pairwise land (a bit like flatland? Am i right). \n:::\n\n\n- degree\n\n- paths\n  - shortest path (betweenness)\n\n$$b_i = \\sum_{h\\neq j\\neq i} \\frac{\\sigma_{hj}(i)}{\\sigma_{hj}}$$\n\nwhere $\\sigma_{hj}$ is the total number of messages from $h$ to $j$ and while $\\sigma_{hj}(i)$ are messages from $h$ to $j$ that go through node $i$.\n\n::: {.callout-tip collapse=\"true\"}\n\nIn `networkX`, they give the possibility to include the endpoints in the shortest path counts. Why?\n\nAnother important calculation when it comes to this kind of approaches is to know how it'll behave when you scale up your system. What is the maximum number of ways shortest paths could go through relevant nodes $i$. In the book, they write: ${(N-1)\\choose 2}=\\frac{(N-1)(N-2)}{2}$. Do you get why?\n\nFinal easter egg,  it is worth pointing out that betweenness is _old_ (@freeman_set_1977). It was understood in terms of information flow in sociology. In this context, what if we wanted to generalize betweenness to higher-order networks. For instance, do messages going through a clique of best friends is any different than going through one of the bffs? We don't need to assume that everything is pairwise, as in the original formulation.\n\n:::\n\n- clustering coefficient\n\n$$C(i) =\\frac{2\\tau(i)}{k_i(k_i-1)}$$\n\nwhere $\\tau_i$ is the number of triangles involving $i$.\n\n::: {.callout-warning collapse=\"true\"}\nDo you think that clustering coefficient has a different flavor than closeness and betweenness? Think about it for a second.\n:::\n\n- closeness:\n$$g_i = \\frac{1}{\\sum_{j\\neq i} \\ell_{ij}}$$\n\n::: {.callout-note collapse=\"true\"}\nIn `networkX`, they write it such that:\n\n$$C(u) = \\frac{n - 1}{\\sum_{v=1}^{n-1} d(v, u)},$$\n\nCan you think how and why you would prefer that over the other one?\n:::\n\n## stats\n\nFocusing on metrics as distributions (have you heard of our lord and savior, the log-log plot), turning local into global:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Menczer et al. 2020 Figure 3.14](images/menczer_fig314.png){#fig-quarto-flow width=75%}\n:::\n:::\n\n\n\nA good first step is to remember your good ol' summary statistics. Given a vector of single things $\\vec{x} = [x_1, x_2, ..., x_n]$, we can summarize with moments:\n\n$$\\langle x \\rangle = \\frac{1}{n} \\sum_{u=1}^n x_i$$\n\n$$\\langle x^2 \\rangle = \\frac{1}{n} \\sum_{u=1}^n x_i^2$$\n\nthen, we can find the variance doing $\\langle x^2 \\rangle - \\langle x \\rangle$. For instance, going back to degrees, we can find the average of the squares of the degrees degree by taking $\\frac{k_1^2 + k_2^2 + ... k_{N-1}^2 + k_N^2}{N}$. Doing this kind of math is interesting because we can then construct quantities of interests of a network's degree distribution, such as:\n\n$$\\kappa = \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle^2}$$\n\nWhen the average squared degree than the sqaure of the average degree, meaning that $\\kappa \\gg 1$, you know that you have a heavy-tailed distribution hiding somewhere. \n\nBecause i find stats confusing, here is another example of how to use averages to say something about networks. The average path length is given by:\n\n$$\\langle \\ell \\rangle = \\frac{\\sum_{i,j} \\ell_{ij}}{{N \\choose 2}} = \\frac{2 \\sum_{i,j} \\ell_{ij}}{N(N-1)}$$\n\nwhere $\\ell_{ij}$ is shortest-path counts between nodes $i$ and $j$, and $N$ is the number of nodes.\n\n## computational\n\nWhat if we wanted to write a library in, say, `Javascript` to implement these properties? How would you got about it? We can start by looking at `networkX` ways of doing things. Here's degree centrality:\n\n#### Degree centrality\n\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://networkx.org/documentation/stable/_modules/networkx/algorithms/centrality/degree_alg.html#degree_centrality\" title=\"Quarto Documentation\"></iframe>\n```\n\n\neasy-peasy code, if you have a `Graph` class object with `degree()` as method. \n\nBut what is this `Graph` object, lets find out in the [doc](https://networkx.org/documentation/stable/_modules/networkx/classes/graph.html#Graph\" title=\"Quarto Documentation):\n\n\n\n```{=html}\n<iframe width=\"780\" height=\"500\" src=\"https://networkx.org/documentation/stable/_modules/networkx/classes/graph.html#Graph\" title=\"Quarto Documentation\"></iframe>\n```\n\n\n\n## what if..\n\nUnderstanding through counterfactuals...\n\n## functional\n\nSome properties are relevant to us because they predict network functionality, e.g.\n\n - connect components x robustness\n\n:::\n",
    "supporting": [
      "centrality_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}